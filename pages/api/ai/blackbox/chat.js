import axios from "axios";
import dbConnect from "../../../../lib/mongoose";
import blackboxChat from "../../../../models/BlackboxChat";
import crypto from "crypto";
export default async function handler(req, res) {
  if (req.method === "GET" || req.method === "POST") {
    const {
      prompt = "Halo",
        web = "false",
        image = "false",
        agent = "false",
        name,
        id,
        continue: continueConv = "false"
    } = req.method === "GET" ? req.query : req.body;
    await dbConnect();
    let previousMessages = [];
    if (continueConv === "true") {
      previousMessages = await blackboxChat.find();
    }
    const generateId = () => crypto.randomBytes(16).toString("hex");
    const requestData = {
      messages: [...previousMessages.map(msg => ({
        id: msg._id.toString(),
        content: msg.content,
        role: msg.role
      })), {
        id: generateId(),
        content: prompt,
        role: "user"
      }],
      id: generateId(),
      previewToken: null,
      userId: null,
      codeModelMode: true,
      agentMode: agent === "true" && name && id ? {
        name: name,
        id: id
      } : {},
      trendingAgentMode: {},
      isMicMode: false,
      userSystemPrompt: null,
      maxTokens: 1024,
      playgroundTopP: null,
      playgroundTemperature: null,
      isChromeExt: false,
      githubToken: "",
      clickedAnswer2: false,
      clickedAnswer3: false,
      clickedForceWebSearch: false,
      visitFromDelta: false,
      mobileClient: false,
      userSelectedModel: null,
      validated: "00f37b34-a166-4efb-bce5-1312d87f2f94",
      imageGenerationMode: image === "true",
      webSearchModePrompt: web === "true",
      deepSearchMode: false,
      domains: null
    };
    try {
      const url = "https://api.blackbox.ai/api/chat";
      const headers = {
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
        accept: "*/*",
        "accept-language": "en-US,en;q=0.5",
        "accept-encoding": "gzip, deflate, br",
        referer: "https://www.blackbox.ai/",
        "content-type": "application/json",
        origin: "https://www.blackbox.ai",
        dnt: "1",
        "sec-gpc": "1",
        "alt-used": "www.blackbox.ai",
        connection: "keep-alive"
      };
      const blackboxResponse = await axios.post(url, requestData, {
        headers: headers
      });
      let cleanedData = blackboxResponse.data.replace(/Generated by BLACKBOX\.AI,.*?blackbox\.ai\n\n/g, "") || null;
      if (image === "true") {
        const imageMatch = cleanedData?.match(/\((https?:\/\/[^\)]+)\)/);
        if (imageMatch && imageMatch[1]) {
          cleanedData = imageMatch[1];
        }
      }
      const newChat = await blackboxChat.findOneAndUpdate({
        content: cleanedData,
        role: "assistant"
      }, {
        content: cleanedData,
        role: "assistant"
      }, {
        upsert: true,
        new: true
      });
      const userChat = await blackboxChat.findOneAndUpdate({
        content: prompt,
        role: "user"
      }, {
        content: prompt,
        role: "user"
      }, {
        upsert: true,
        new: true
      });
      if (continueConv === "true") {
        previousMessages.push({
          id: userChat._id.toString(),
          content: prompt,
          role: "user"
        });
        previousMessages.push({
          id: newChat._id.toString(),
          content: cleanedData,
          role: "assistant"
        });
        const continuedRequestData = {
          messages: previousMessages.map(msg => ({
            id: msg.id,
            content: msg.content,
            role: msg.role
          })),
          ...requestData
        };
        const continuedBlackboxResponse = await axios.post(url, continuedRequestData, {
          headers: headers
        });
        cleanedData = continuedBlackboxResponse.data.replace(/Generated by BLACKBOX\.AI,.*?blackbox\.ai\n\n/g, "") || null;
        if (image === "true") {
          const imageMatch = cleanedData?.match(/\((https?:\/\/[^\)]+)\)/);
          if (imageMatch && imageMatch[1]) {
            cleanedData = imageMatch[1];
          }
        }
        res.status(200).json({
          result: cleanedData
        });
      } else {
        res.status(200).json({
          result: cleanedData
        });
      }
    } catch (error) {
      res.status(500).json({
        error: "Terjadi kesalahan",
        details: error.message
      });
    }
  } else {
    res.setHeader("Allow", ["GET", "POST"]);
    res.status(405).json({
      error: `Metode ${req.method} tidak diizinkan`
    });
  }
}